[{"id":0,"href":"/Overlord/en/","title":"Overlord","parent":"","content":""},{"id":1,"href":"/Overlord/en/overview/","title":"Overview","parent":"Overlord","content":""},{"id":2,"href":"/Overlord/en/overview/actors/ruler/","title":"Ruler","parent":"Actors","content":"The rule creation process for Overlord is fairly straightforward, but requires an understanding of the rules-specific DSL. The creator of Rules is the Overlord user who understands security problems and wants to add value by designing generic tests on controls (what needs to be verified).\nIn this case, the community will be its main objective, since the creation of rules adds value within it in the form of consolidation of how to recognize that a control is effectively working as designed, and that both the generic test and the adaptation for a specific environment can be shared and contrasted with the rest of the industry, facilitating the discussion about something factual and verifiable\nThe value she offers to the community is its specific mastery of a specific technology platform and how to specify and instantiate a generic rule. In many of the examples in this documentation we use a network environment specific rule that the TLS version of a web service must be above 1.3. This is a perfect example of a rule created by a security expert. This rule is an instantiation that belongs to a general recommendation: \u0026ldquo;Communication channels with customers must be secure.\u0026rdquo;\nThe task of the rule creator is vital in that he has the technical security knowledge necessary to materialize the tests in generic environments. Understanding as a general environment for example the public cloud and as a specific environment a specific project of the public cloud; that would be the responsibility of the technical managers of each specific project. Although the Security Risk Manager should establish in which cases controls must exist, the rule creator is a necessary ally that says which rules are necessary to verify the existence and effectiveness of the controls in the different environments.\nIn many cases the rule maker does not have to understand the technical details down to the last detail. So the DSL that defines the rules should not describe the process at the level of what steps are necessary; since it would be very difficult to reuse for different environments, as happens nowadays to the tests of controls written directly in code. Rather than establishing how things are checked, it is more important to know WHAT needs to be checked.\nIn other cases, technical knowledge is vital for the correct resolution and the rule must specify what programs and procedures must be carried out. In this case the rules provide the ability to add these technical details from a high level of abstraction.\nParameterizing    For the rules to be truly reusable and useful for the community it is sometimes necessary that they can already be adjusted at a high level of abstraction. To do this, the rules have the goal parameters. These allow the rule builder to tailor the security rule to a certain level of risk based on its risk analysis.\nPutting a simple example we can discuss a rule with the following free text (final syntax is not closed yet).\nEvery https service must have TLS version at least ($tls_min) In this case the \u0026ldquo;$ tls_min\u0026rdquo; parameter can be set to various values depending on the business or use case. For example, if we have high security requirements it could be the latest version.\nAlso, if this detail is strategic, it can be forced to be defined, and that it cannot be rewritten later, only in the first abstraction steps. For this, the technical parameters have a prefix that can be put before the \u0026ldquo;$\u0026rdquo; symbol; this is tg (from target).\nThe previous rule would look like this:\nEvery https service must have TLS version at least (tg$tls_min) For more information on the rules, they will be described in their own documentation.\n"},{"id":3,"href":"/Overlord/en/overview/actors/srm/","title":"Srm","parent":"Actors","content":"Security Risk Manager focuses on threat modeling, risks, and controls to mitigate them. However, they usually lose the last mile of verification that the controls they specified are operational or not, especially in Continuous Deployment and Infrastructure as Code environments, so Overlord should be one of the tools that can provide them the most value.\nHaving a complete view of all controls across the company is a task addressed by risk management software (ASR\u0026amp;TM: Application Security Requirements and Threat Modeling, or GRC/IRM). In some of those programs it is possible to check, using code integrated in the tool, what is the status of some typical controls.\nBut for now, no tool offers the integration and ease to be able to check, in the most automated way possible, all the controls of the organization. The ability to federate all systems and tools into a single process of actual test execution can be a critical step to achieve continuous risk management.\nCurrent development trends have posed a real technology challenge for Security Risk Managers. Automation and technological proliferation have pushed the demand for security controls and their implementation to the limit.\nAlthough Overlord is not a risk management software, its integration possibilities with one of it are wide and extensible. Opening the door to a symbiosis that can change a typical trend of this type of work; from checking only the most essential at any given time, to being able to have a true, continuous and updated overview of each change.\nOverlord offers you the possibility of managing both a generic catalog of rules that can be associated with any technical reality, as well as a codebase in which you can establish relevant risk level verification details.\nRules    Overlord’s Rules are intended to be easily written by any security expert. It is not necessary to learn to code in any programming language, nor is it necessary to learn a long list of commands to establish how things should be done in each environment. They define the what but not the how, although the how will be available for approval (test effectiveness) and audit (verification integrity).\nA rule can be specified and adapted to any environment, because it establishes the security control check objective in an abstract way. In this way it can be shared and adapted.\nOn the other hand, both the auxiliary code that allows Overlord to obtain the intermediate parameters with which to configure the atomic test code (atomic code), as well as these same atomic tests already developed in the form of products, open source tools or small internal developments can be integrated into Overlord independently and decoupled from the rules.\nAn Overlord system with enough built-in Atomic code may be able to execute a large set of new rules without the need to add more code. This is because the Overlord system will try to find its way through the existing code to the test target.\nAnd if it cannot find their way, it can give you some alternatives so that the amount of code to add to the system is always the minimum necessary, creating a backlog of elements to add to maximize the test coverage that can be prioritized according to the risk of failing to verify the associated controls.\nAtomic Code    As a Risk expert, it is not necessary to know how to code, but it is necessary to be familiar with the differences between different control verification processes.\nIt is not the same level of assurance to check a configuration file than, for example, to use a network analysis tool to verify in the real system that a condition is met or to launch said tool from the same network or from another one.\nThe Atomic code is always associated with a description of how the information is being obtained. Using the check parameters (Check Block) you can force Overlord to use a certain piece of code in an execution; thus ensuring that the way things are done meets the security requirements of a specific project.\n"},{"id":4,"href":"/Overlord/en/overview/actors/programmer/","title":"Programmer","parent":"Actors","content":"From a programmer\u0026rsquo;s perspective the idea of a universal tool may sound crazy. We are used to dealing with software as a whole that must solve the problem; although microservices are changing this trend slowly.\nBut the automatic search for paths and ancillary information that Overlord needs so that it can be developed independently is not something that can be \u0026ldquo;solved\u0026rdquo; globally. We need a smart, modular and extensible approach. Like an operating system or a compiler.\nOverlord will need small pieces of code in order to carry out its information gathering tasks. In these cases, each piece of code must have two parts, gathering and execution.\nGathering    When we create code for Overlord it needs an interface to know what data we can ask for. This is declared in the atomic code registry metadata; if for example we need our code to provide bread, we will declare it so.\nYour browser does not support the video tag.  Properties have namespace (eg ip.net) simply because Overlord can understand IP in many contexts. For example, it could be an AWS IP, the property in that case could be called something like \u0026ldquo;ip.aws.com\u0026rdquo;. Don\u0026rsquo;t worry too much about the name now, you don\u0026rsquo;t need a central entity to assign names. Although the names are up to you, looking at the community can be very advantageous.\nNow that Overlord knows what you can offer, the system will send you requests with a set of properties, for example a netmask, a domain name and other things. Keep in mind that you will receive all possible properties, not just the ones that interest you. If with these properties you can collect the information, your code will be able to pass the full name of the property you provide, and you have finished the gathering step.\nYour browser does not support the video tag.  In the event that you cannot provide that information because there are missing parameters, you will have to return what properties you need to carry out your task. And these can be many, since you can carry out your task in different ways.\nYour browser does not support the video tag.  A relevant feature with respect to traditional graphs is that the gathering atomic code can manage how to consider an incoming request. It is not expected to always provide the same answer, this can be based on multiple factors, in fact that is why it is \u0026ldquo;dynamic\u0026rdquo;. The code is expected to always have the same output, but it must be flexible on input. This allows us to have great flexibility for cases we do not yet know about.\nAlso with the same parameters, but different user, we can require different things. If the query, for example, is made by the system administrator, we do not require any additional permission. If, on the other hand, an anonymous user makes the same query, we can require an additional authentication parameter to the system.\nExecuting    When Overlord invokes the execution code, it will receive, again and symmetrically to the previous case, all the parameters it has at that time. Among these, surely there is a way to get the information. If you can get the information in more than one way, it is up to you to decide how it will be executed to achieve your goal.\nYour browser does not support the video tag.  Once the code is executed, it will deliver the result to Overlord. It\u0026rsquo;s that simple (probably through an exchange API to be decided, but always as isolated as possible to don’t introduce dependencies in the atomic code)\nPutting the process in perspective    This process seems pretty straightforward, but using these small pieces of code (that can themselves invoque more complex applications like SAST), Overlord is able to compose highly complex solutions.\nAdded Value    Through its checks Overlord can be a general checking framework for your own code. It does not have to be used only in a business environment, nor is it a tool that requires large amounts of infrastructure. We want to keep it simple so it can be used standalone and offer a comprehensive testing capability.\nWe know that there are \u0026ldquo;Property based testing\u0026rdquo; frameworks, and maybe you are very comfortable with them. They may even offer better abstractions for you. But keep two things in mind:\n When you write code for Overlord you contribute to a community beyond your test case. If that framework is so good, you can integrate it into Overlord! and thus contribute to a larger community.  We try to keep the integration effort as low as possible, adding value at a low cost.\nIn addition to checking security controls, you can use the Overlord abstractions as an independent tool. We believe that the dynamic graph can be adapted to a huge number of cases, specially in high uncertainty environments.\n"},{"id":5,"href":"/Overlord/en/dronetown/examples/","title":"Examples","parent":"Dronetown","content":""},{"id":6,"href":"/Overlord/en/dronetown/proc/","title":"Proc","parent":"Dronetown","content":""},{"id":7,"href":"/Overlord/en/dronetown/agents/","title":"Agents","parent":"Dronetown","content":""},{"id":8,"href":"/Overlord/en/dronetown/","title":"Dronetown","parent":"Overlord","content":"DroneTown is a support metaphor to help to understand Overlord system needs, because its level of abstraction can cause uncertainty in the implementation details.\nMetaphore cast    Within DroneTown we have several actors that will represent parts of a hypothetical real Overlord system. To better understand the features we should black-box its internals until we understand the system’s core\nDroneTown    The city itself is an integral part of the metaphor, it represents the system as a whole without worrying about its internal organization.\nAll DroneTown members who are represented as a building/shop act in a similar way. When a drone comes to them, they sequentially process their brain’s content until they find an order they understand. At that moment they carry out their task. And if they don\u0026rsquo;t find an order they understand, they send the drone to a default site (which is usually the default control tower)\nDock    The drones leave the Dock to carry out their errands. These drones only have two orders in their brains:\n To obtain their target information Return to the Dock  If a drone has no target, the tower will attend its second instruction and send it back to the Dock.\nIf, on the contrary, it does not have the instruction to return to the Dock, the drone will try to obtain its target, and then end up in the Junkyard whether it succeeds or not.\nJunkyard    It is the place where the drones arrive if they do not have a set of correct orders in the brain or if they cannot fulfill their objective.\nInspecting these drones can reveal unknown requirements from the drone\u0026rsquo;s objectives, so they return information about their journey even if it was not asked for.\nTorre    The tower is a structural DroneTown building, it has two responsibilities:\n Record all DroneTown addresses Register all DroneTown stores  If the tower finds an instruction to send the drone to a specific address, it simply deletes this instruction and sends the drone to that address. This is the common mechanism used by other shops when they have pending processes\nIf the tower finds an instruction to obtain a certain item, it searches the site among its addresses, and sends it to that address with an instruction to buy.\nIt is possible that there is more than one store that supplies a certain product, so in that case the tower will dispatch as many drones as there are stores to ensure that all possibilities are explored. Each of these drones is a complete clone of the one that entered the tower, including its belongings and instructions.\nIt is also possible that a drone is targeting an item that is not registered in the tower. In this case the tower will send the drone to the Junkyard. The tower is the only building that will send a drone to the Junkyard when it doesn\u0026rsquo;t know how to proceed. The rest of the buildings send the drone to the tower if they don\u0026rsquo;t know what to do.\nShop    All stores work in a similar way. They can carry out three basic operations:\n In the event that a drone arrives, and they have everything it needs, they give the item the drone is looking for and change the purchase operation for a successful purchase. In the event that a drone arrives, but they lack what it needs, they will add an instruction to return to the store and then another instruction to get what they lack. In any case they always send the drone back to the tower.  Special transactions    Inside Drone Town, and without breaking its rules, there are some curious shops that allow you to control the most complex errands. In the case that a store, for example, can obtain an item from others, we need to tell the drone that it can obtain one or the other. Similar to a logical OR. It is also possible that a store requires more than one item to carry out the transaction, so in the same way, we need to tell the drone that we need both one item and the next. Similar to an AND.\nTo solve these complexities there are two special stores\nANDrés Store    This store takes care of the orders and requirements that require a logical AND. When a drone arrives looking for its item (the AND), they examine the AND members. For each of the items, it examines whether the drone already has them or not. And in the case of not having them, it adds an instruction to buy that product.\nAlways, before sending the drone back to the tower, it removes any traces of its activity to keep things simple.\nHectOR Store    In this case the store works in a similar way. It inspects the backpack of the drone, if it already has any of the items you need, erase the trace of the store and send it to the tower.\nIf it doesn\u0026rsquo;t have any of the items, HectOR will dispatch as many cloned drones as items in the instruction. This ensures that they will have the maximum number of chances to complete the errand successfully. This operation is similar to the one carried out by the tower when there are several stores, but in the case that there are several requirements.\n"},{"id":9,"href":"/Overlord/en/overview/actors/","title":"Actors","parent":"Overview","content":"In this documentation section we are going to give a perspective from different points of view familiar to users who can benefit from Overlord.\nBeing a tool that covers a universal scenario, we have realized that users tend to see it from their personal point of view, and it is a bit difficult for them to take the \u0026ldquo;universal\u0026rdquo; step. Because of this we will use a familiar scenario and then expand that perspective to try to describe Overlord.\n"},{"id":10,"href":"/Overlord/en/overview/rules/","title":"Rules","parent":"Overview","content":"In the case of the execution of a complete rule, we can see the complete abstraction process from the most general rule to the piece of code finally executed.\nThis is a simple example; a failed rule, an incomplete rule and other secondary scenarios are reserved for other examples. Currently the Overlord PoC is focused on viability so it develops just the \u0026ldquo;Happy Path\u0026rdquo;.\nThe complete log is also excluded from this example, because due to its length it would be very complex to explain in detail. In the log there will be the partial results of all the intermediate executions, tools and paths of the discarded dynamic graph.\nA complete rule     .gdoc-expand { margin-bottom: 0rem; margin-top: 0rem; } .blue{ background-color: #9acdff; }   Recommendation / Generic Rule ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) At this point a rule is an abstract high-level recommendation. Its purpose is to recommend a transversal and generic control to all the projects of the company, and it’s enough as a “definition of done” or “security feature story” to check if all the communications of the company comply with this control.\nIt also enables collaboration between companies/organizations on a very general level as it doesn’t need details about the targets ($url) and goals (ch$version).\nIn this rule we can observe some general concepts such as the reserved word * All * that indicates that this rule must be true for all the following members. We can also see some words in parentheses; those are the parameters that allow you to instantiate this rule for a specific environment.\nDon’t pay attention to the functional details of the rule, as it progresses through the system you will understand the whole process.\nActors    The main producers of these rules will be:\n Security communities (Ex.: OWASP) Standardization bodies and agencies (Ex.: NIST) Security and infrastructure vendors at large  The main stakeholders in these rules will be:\n CISOs, CTOs, Compliance\u0026amp;Audit    \u0026#43;Hash ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 This rule has a SHA256 hash so that it can be referenced in community discussions.\n  General Instantiation ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 At this point we are specifying in the rule that in our organization we consider a TLS version of 1.3 or higher to be secure. This block allows you to set the parameters, which, as we saw in the previous point, have a \u0026ldquo;$\u0026rdquo; symbol and are also enclosed in parentheses.\nIf you notice this parameter has the letters ch before the \u0026ldquo;$\u0026rdquo; symbol, this tells Overlord that this parameter can only be specified in the \u0026ldquo;Check\u0026rdquo; phase; which is where the cross-organizational criteria are established.\nThose criteria express the security posture and should be the result of a threat modeling or a compliance constrain\nActors    These types of decisions are made across an organization. Each organization has its own governance model to select and approve the final criteria on each adjustable goal.\n  \u0026#43;Hash ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 This rule has a SHA256 Hash to be able to refer to it in the ASR-TM (Application Security Requirements and Threat Management) or GRC (Governance, Risk management, and Compliance) of the organization.\n  Target ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 In the control testing process it is necessary to add some technical parameters of the specific project system. In this case we are adding one (dns_ip) that is not explicitly in the rule, but can be used to discover the targets.\nThis is so because in the process of checking security controls, how things are done (the exact mechanism used and the confidence of the results) may be relevant at a certain moment. Due to this to obtain the data, the dynamic graph built inside Overlord will preferably use the paths it already knows.\nActors    In this case, both the technical manager and his team are involved in the process. It may be necessary to manage the partial results of Overlord to distinguish from those possibilities of obtaining information those that fit in the current project.\nIt is from this review process that you can decide what extra parameters should be provided to Overlord to check the control in one way or another.\nThey can also see in the log how the check has been carried out without having to agree to it previously; so that the Overlord’s principle of segregation of concerns will be preserved.\n  \u0026#43;Hash ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 In this case the identifier of the targeting process includes the technical parameter. This will change in case the DNS server associated with this particular process changes. Overlord reinforces transparency whenever possible.\nIf it is not relevant, we can simply refer to the identifier of the upper level and that way we will not have notifications every time a detail of the environment changes.\n  Execution ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] For the execution we need to provide to the rule the rest of the required parameters. In this case, the domain names we want to test.\nActors    In this case, those in charge of executing the testing code, either manually or automatically. They can include the following profiles:\n Developers interested in improving code security Auditors who want to check the status of a control Security and risk analysts or operators who want to check the status of a control    \u0026#43;Hash ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] == execution id 26b67743880b9bc6cbdbe66d51abd2d8846822bf7325d2e2bef08c611a6023d5 Again, the identifier hash includes the execution parameters so that the execution conditions cannot be changed without it changing\n  Result ↕  =\u0026gt; Rationale PCI DSS 4.1 Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission over open, public networks. =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] == execution id 26b67743880b9bc6cbdbe66d51abd2d8846822bf7325d2e2bef08c611a6023d5 == Execution path dns_mask_tool ssl_tools rule_check == Final Rule All [ (\u0026quot;one.com\u0026quot; as $url) must have (\u0026quot;1.3\u0026quot; as g$tls_version) \u0026gt;= (\u0026quot;1.3\u0026quot; as ch$version), (\u0026quot;two.com\u0026quot; as $url) must have (\u0026quot;1.3\u0026quot; as g$tls_version) \u0026gt;= (\u0026quot;1.3\u0026quot; as ch$version), ] == Result All Rules OK == Result id c04a56d97f7e8e6d506e15c9d37ef45849fdb90a06d6b21d8d41b6516adfc67b In the final step, using the dynamic graph built by Overlord, we follow the following steps:\n First of all we are executing code that, using the \u0026ldquo;DNSMask\u0026rdquo; tool, will resolve the urls using a specific DNS server (passed as a parameter in the \u0026ldquo;Target Block\u0026rdquo;). Then the ssl analysis tool is used and the searched property is extracted (tls_version). The rule is expanded with this information. Rule is evaluated  In this way we obtain an \u0026ldquo;All Rules OK\u0026rdquo;. Our control is working.\nFinally, we can see that a new hash has been generated, which includes data from all of the previous steps.\nActors    The result of the execution is something interesting to all those involved in the process. In this case, the final hash also includes the system time to prevent previous results from being reused. Or to use cached intermediate results if a rule expiration is set (not in this example).\nIf some of the final (atomic) testing code doesn’t exist yet (dns_mask_tool or ssl_tools in this example), it must be designed, coded and ideally open sourced. Who and how the tools are selected and vetted is a responsibility of the organization, Overlord provides total transparency and audit to automate the trust in the final result.\n  "},{"id":11,"href":"/Overlord/en/intro/","title":"Intro","parent":"Overlord","content":"Overlord    Overlord es una implementación de ejemplo de la iniciativa SUSTO.\nOverlord plantea una solución válida al testing de seguridad universal y sistemático dentro de las empresas modernas.\n"},{"id":12,"href":"/Overlord/en/tags/","title":"Tags","parent":"Overlord","content":""}]