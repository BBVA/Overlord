[{"id":0,"href":"/Overlord/overview/actors/ruler/","title":"Creador de Reglas","parent":"Actors","content":"El proceso de creación de reglas para Overlord es bastante sencillo, pero requiere de entendimiento del DSL específico para reglas. El creador de Reglas es aquel usuario de Overlord que entiende los problemas de seguridad y quiere aportar valor diseñando tests genéricos sobre controles (qué hay que verificar).\nEn este caso, la comunidad será su principal objetivo, ya que la creación de reglas aporta valor dentro de la misma en forma de consolidación de cómo reconocer que un control está efectivamente funcionando tal como se diseñó, y que tanto el test genérico como la adaptación para un entorno específico pueda ser compartido y contrastado con el resto de la industria facilitando la discusión sobre algo tangible\nEl valor que aporta a la comunidad es su dominio específico de una plataforma tecnológica concreta y cómo concretar una regla genérica. En muchos de los ejemplos de esta documentación usamos una regla específica de entornos de red por la cual la versión de TLS de un servicio web debe estar por encima de 1.3. Este es un ejemplo perfecto de una regla creada por un experto en seguridad. Esta regla es una instanciación que pertenece a una recomendación general: \u0026ldquo;Los canales de comunicación con los clientes deben ser seguros\u0026rdquo;.\nLa tarea del creador de reglas es vital en cuanto a que tiene el conocimiento técnico de seguridad necesario para materializar los tests en entornos genéricos. Entendiendo como entorno general por ejemplo la nube pública y como entorno específico un proyecto en concreto de la nube pública; que sería responsabilidad de los responsables técnicos de cada proyecto concreto. Si bien el Security Risk Manager debe establecer en qué casos deben existir controles, el creador de reglas es aliado necesario que dice qué reglas son necesarias para verificar la existencia y eficacia de los controles en los diferentes entornos.\nEn muchas ocasiones el creador de reglas no tiene por qué entender los detalles técnicos hasta el último detalle. Por lo que el DSL que define las reglas no debe describir el proceso a nivel de qué pasos son necesarios; ya que sería muy difícil de reutilizar para diferentes entornos, como le pasa hoy en día a los test de controles escritos directamente en código. En lugar de establecer el cómo se comprueban las cosas es más importante saber QUÉ debe comprobarse.\nEn otros casos el conocimiento técnico es vital para la correcta resolución y la regla debe especificar qué programas y procedimientos se deben llevar a cabo. En este caso las reglas proveen la capacidad de agregar estos detalles técnicos desde un alto nivel de abstracción.\nParametrizando    Para que las reglas sean realmente reutilizables y útiles para la comunidad en ocasiones es necesario que se puedan ajustar ya en un alto nivel de abstracción. Para esta labor las reglas tienen los parámetros de Objetivo. Estos permiten al creador de reglas que la empresa adapte la regla de seguridad a un determinado nivel de riesgo en función de su análisis de riesgos.\nPoniendo un ejemplo sencillo podemos hablar de una regla con el siguiente texto libre (la sintaxis no está cerrada todavía).\nEvery https service must have TLS version at least ($tls_min) En este caso el parámetro \u0026ldquo;$tls_min\u0026rdquo; se puede establecer a varios valores que dependen del negocio o caso de uso. Por ejemplo, si tenemos altos requisitos de seguridad podría ser la última versión.\nAdemás si este detalle es estratégico se puede forzar a que sea definido, y que no pueda ser reescrito después, solamente en los primeros pasos de abstracción. Para esto los parámetros técnicos tienen un prefijo que se puede poner antes del símbolo del \u0026ldquo;$\u0026quot;; esté es tg (de target).\nLa anterior regla quedaría así:\nEvery https service must have TLS version at least (tg$tls_min) Para obtener mayor información al respecto de las reglas, estas estarán descritas en su propia documentación.\n"},{"id":1,"href":"/Overlord/","title":"Overlord","parent":"","content":""},{"id":2,"href":"/Overlord/overview/","title":"Overview","parent":"Overlord","content":""},{"id":3,"href":"/Overlord/overview/actors/srm/","title":"Security Risk Manager","parent":"Actors","content":"El Security Risk Manager se centra en el modelado de amenazas, los riesgos y los controles para mitigarlos. Sin embargo suele perder la última milla de verificación de que los controles que especificó están o no operativos, sobre todo en entornos de de Despliegue Contínuo e Infrastructure as Code, por lo que Overlord debería ser una de las herramientas que más valor le puede aportar.\nEl tener visión de todos los controles de forma transversal a la compañía es una tarea abordada por software de gestión de riesgos (ASR\u0026amp;TM: Application Security Requirements and Threat Modeling o GRC/IRM). En algunos de los programas se pueden llegar a comprobar, mediante código integrado en la herramienta, cuál es el estado de algunos controles típicos.\nPero por ahora ninguna herramienta ofrece la integración y facilidad para poder comprobar de la forma más automatizada posible, todos los controles de la organización. La posibilidad de integrar de forma federada todos los sistemas y herramientas en un solo proceso de ejecución real de la comprobación puede ser un paso decisivo para la gestión de riesgos contínua.\nLas tendencias de desarrollo actuales han planteado un reto tecnológico real a los Security Risk Manager. La automatización y la proliferación tecnológica han llevado al límite la demanda que se exige en cuanto a controles de seguridad y su implantación.\nPese a que Overlord no es un software de gestión de riesgos sus posibilidades de integración con este son amplias y extensibles. Abriendo la puerta a una simbiosis que puede cambiar una tendencia típica de este tipo de trabajos; de comprobar solo lo más esencial en un momento dado, a poder tener una verdadera visión de conjunto contínua y actualizada en cada cambio.\nOverlord le ofrece la posibilidad de gestionar tanto un catálogo genérico de reglas asociables a cualquier realidad técnica, como una base de código en la que puede establecer incluso detalles de la comprobación relevantes a nivel de riesgos.\nReglas    Las Reglas de Overlord están pensadas para poder ser escritas fácilmente por cualquier experto en seguridad. No es necesario aprender a programar en ningún lenguaje, ni tampoco aprender una larga lista de órdenes para establecer como deben de hacerse las cosas en cada entorno. Definen el qué pero no el cómo, aunque el cómo estará disponible para su aprobación (eficacia del test) y auditoría (integridad de lo verificado).\nUna regla puede concretarse y adaptarse a cualquier entorno, debido a que establece el objetivo de comprobación del control de seguridad de forma abstracta. De esta forma se puede compartir y adaptar.\nPor otro lado, tanto el código auxiliar que permita a Overlord obtener los parámetros intermedios con los que configurar el código del test atómico (código atómico), como estos mismos tests atómicos ya desarrollados en forma de productos, herramientas open source o pequeños desarrollos internos pueden ser integrados en Overlord de forma independiente y desacoplada a las reglas.\nUn sistema Overlord con el suficiente código Atómico integrado puede ser capaz de ejecutar un gran conjunto de nuevas reglas sin necesidad de agregar más código. Esto es así porque el sistema Overlord intentará buscar el camino por el código existente hasta el objetivo de la comprobación.\nY si no puede encontrar el camino, puede dar algunas alternativas para que la cantidad de código a añadir al sistema sea siempre la mínima necesaria, creando un backlog de elementos a añadir para maximizar la cobertura de comprobaciones que puede ser priorizado según el riesgo de la no comprobación de los controles asociados.\nCódigo Atómico    Como experto en Riesgos no es necesario saber programar, pero si que es necesario estar familiarizado con las diferencias entre distintos procesos de comprobación de controles.\nNo es lo mismo a nivel de aseguramiento consultar un fichero de configuración que, por ejemplo, usar una herramienta de análisis de red para comprobar en sistema real que se cumple una condición o lanzar dicha herramienta desde la propia red o desde otra.\nEl código Atómico lleva siempre asociado una descripción de cómo se está obteniendo la información. Mediante los parámetros de comprobación (Check Block) se puede forzar a Overlord para que use una determinada pieza de código en una ejecución; asegurando así que la forma en la que se hacen las cosas cumple con los requisitos de seguridad en un proyecto en concreto.\n"},{"id":4,"href":"/Overlord/overview/actors/programmer/","title":"Programmer","parent":"Actors","content":"Desde la perspectiva de un programador la idea de herramienta universal puede sonar disparatada. Estamos acostumbrados a enfrentarnos al software como un todo que debe resolver el problema; aunque los microservicios estén cambiando esta tendencia poco a poco.\nPero la búsqueda automática de caminos e información auxiliar que necesita Overlord para que pueda desarrollarse de manera independiente no es algo que se pueda \u0026ldquo;resolver\u0026rdquo; globalmente. Necesitamos una aproximación inteligente, modular y extensible. Como un sistema operativo o un compilador.\nOverlord necesitará de pequeños trozos de código para poder llevar a cabo sus tareas de recopilación de información. En estos casos, cada trozo de código debe tener dos partes, la consultiva y la ejecutiva.\nConsultando    Cuando creamos código para Overlord este necesita un interfaz para saber qué datos le podemos pedir. Esto se declara en los metadatos de registro del trozo de código; si por ejemplo necesitamos que nuestro código provea de pan, así lo declararemos.\nYour browser does not support the video tag.  Las propiedades tienen espacio de nombre (por ejemplo ip.net) simplemente porque Overlord puede entender la ip en muchos contextos. Por ejemplo, puede ser una ip de AWS, la propiedad en ese caso debería llamarse algo parecido a \u0026ldquo;ip.aws.com\u0026rdquo;. No te preocupes mucho por el nombre ahora, no necesita una entidad central que asigne nombres. Aunque los nombres los pones tú, fijarse en la comunidad puede ser muy ventajoso.\nAhora que Overlord sabe qué puedes ofrecer, el sistema te enviará peticiones con un conjunto de propiedades, por ejemplo, una máscara de red, un nombre de dominio y otras cosas. Ten en cuenta que recibirás todas las propiedades posibles, no solo las que te interesen a ti. Si con estas propiedades puedes recopilar la información, tu código le podrá pasar el nombre completo de la propiedad que provees, y ya has terminado la parte consultiva.\nYour browser does not support the video tag.  En el caso de que no puedas proveer de esa información porque te faltan parámetros, deberás devolver qué propiedades necesitas para llevar a cabo tu tarea. Y estas pueden ser muchas, ya que puedes llevar a cabo tu tarea de diferentes formas.\nYour browser does not support the video tag.  Una capacidad diferenciadora respecto a los grafos tradicionales es que el código atómico de consulta puede gestionar como considerar una petición entrante. No se espera de él que proporcione siempre la misma respuesta, esta puede estar basada en múltiples factores, de hecho por eso es “dinámico”. Se espera del código que tenga siempre la misma salida, pero debe ser flexible en la entrada. Esto permite tener una gran flexibilidad frente a casos que todavía no conocemos.\nTambién ante los mismos parámetros, pero diferente usuario, podemos requerir otras cosas. Si la consulta, por ejemplo, la hace el administrador del sistema no requerimos ningún tipo de permiso adicional. Si por otro lado un usuario anónimo hace la misma consulta podemos requerir un parámetro de autenticación en el sistema.\nEjecutando    Cuando Overlord invoca el código ejecutivo este recibirá, de nuevo y de forma simétrica al anterior caso, todos los parámetros que posee en ese momento. Entre éstas, seguro que está la forma de conseguir la información. Si puedes conseguir la información de más de una forma, queda en tu mano decidir cómo se ejecutará para conseguir su objetivo.\nYour browser does not support the video tag.  Una vez ejecutado el código éste entregará el resultado a Overlord. Así de simple (seguramente mediante un API de intercambio por decidir todavía, pero siempre de la forma más aislada posible para no introducir dependencias en el código atómico)\nPoniendo el proceso en perspectiva    Este proceso parece bastante sencillo, pero utilizando estos pequeños fragmentos de código (que pueden invocar aplicaciones más complejas como SAST), Overlord puede componer soluciones muy complejas.\nValor Aportado    Overlord a través de sus comprobaciones puede ser un framework de comprobación generalista en tu propio código. No tiene por qué usarse solo a nivel empresarial, ni es una herramienta que requiera de grandes cantidades de infraestructura. Queremos mantenerla simple para que se pueda usar en solitario y ofrecer una capacidad de testing más exhaustiva.\nSabemos que hay frameworks de \u0026ldquo;Property based testing\u0026rdquo;, y seguramente te encuentres muy cómodo con ellos. Incluso es posible que te ofrezcan mejores abstracciones para ti. Pero ten en cuenta dos cosas:\n Cuando creas código para Overlord aportas a una comunidad más allá de tu caso de testing. Si ese framework es tan bueno ¡puedes integrarlo en Overlord! y aporta así a una comunidad más grande.  Intentamos que el esfuerzo de integración sea lo menor posible, para que ese valor aportado tenga un coste bajo.\nAdemás de comprobar controles de seguridad, puedes usar las abstracciones de Overlord como herramientas. Creemos que el grafo dinámico puede adaptarse a una cantidad ingente de casos, especialmente en entornos de alta incertidumbre.\n"},{"id":5,"href":"/Overlord/dronetown/examples/","title":"Examples","parent":"Dronetown","content":""},{"id":6,"href":"/Overlord/dronetown/proc/","title":"Proc","parent":"Dronetown","content":""},{"id":7,"href":"/Overlord/dronetown/agents/","title":"Agents","parent":"Dronetown","content":""},{"id":8,"href":"/Overlord/dronetown/","title":"Dronetown","parent":"Overlord","content":"Esta es una metáfora de soporte para ayudar a la compresión del sistema Overlord, debido a que el nivel de abstracción del mismo puede provocar incertidumbre en los detalles de implementación.\nIntegrantes de la metáfora    Dentro de DroneTown tenemos varios actores que representarán partes de un hipotético sistema real Overlord. Para entender la funcionalidad debemos obviar esos sistemas dandolos por ciertos hasta que comprendamos el sistema en su nucleo.\nDroneTown    La propia ciudad es un integrante de la metáfora, representa el sistema en su conjunto sin preocuparse de la localización o división del mismo.\nTodos los integrantes de DroneTown que están representados como edificio actuan de forma similar. Cuando les llega un dron procesan secuencialmente su cerebro hasta que encuentran una orden que entienden. En ese momento llevan a cabo su tarea. Y si no encuentran una orden que entiendan envian al dron a un sitio por defecto (que suele ser la torre de control por defecto)\nDock    Los drones salen del Dock para cumplir sus recados. Estos drones solo tienen dos ordenes en sus cerebros:\n Obtener la Información obejetivo Volver al Dock  En el caso de que un dron no tenga objetivo la torre atenderá a su segunda instrucción y lo enviará de vuelta al Dock.\nSi por el contrario no tiene la instrucción de volver al Dock, el dron intentantará obtener su objetivo, para después, acabar en el Junkyard lo consiga o no.\nJunkyard    Es el sitio al que llegan los drones si no tienen un conjunto de ordenes correctas en el cerebro o si no pueden cumplir su objetivo.\nLa inspección de estos drones puede revelar los requisitos no conocidos del objetivo del dron, por lo que vuelven siempre con información aunque no sea la que se ha pedido.\nTorre    La torre es un edificio estructural de DroneTown, tiene dos responsabilidades:\n Registrar todas las direcciones de DroneTown Registrar todas las tiendas de DroneTown  Si la torre se encuentra una instrucción para enviar al dron a una dirección en concreto, simplemente borra esta instrucción y envia al dron a esa dirección. Este es un mecanismo común usado por los otros edificios cuando tienen procesos pendientes.\nSi la torre se encuentra una instrucción para obtener un determinado producto, busca entre sus direcciones el sitio, y lo envía a esa dirección con una instrucción de comprar.\nEs posible que haya más de una tienda que proveea un determinado producto, por lo que en ese caso la torre fletará tantos drones como tiendas haya para asegurase de que se exploran todas las posibilidades. Cada uno de estos drones es un clon completo del que entro en la torre, incluyendo sus pertenencias e instrucciones.\nTambién es posible que un dron tenga como objetivo un producto que no esta registrado en la torre. En este caso la torre enviará al dron al Junkyard. La torre es el único edificio que enviará un dron al Junkyard cuando no sepa como proceder. El resto de edificios envian al dron a la torre si no saben que hacer.\nTienda    Todas las tiendas funcionan de una forma similar. Pueden llevar a cabo tres operaciones básicamente:\n En el caso de que les llege un dron, y que tengan todo lo necesario, le dan el producto que viene buscando y cambian su operación de compra por una de compra exitosa. En el caso de que les llege un dron, pero que les falte lo que necesitan, le agregaran una instrucción que vuelva a la tienda y luego otra instrucción para que consiga lo que le falta. En cualquier caso siempre envian al dron de vuelta a la torre.  Operaciones especiales    Dentro de Drone Town, y sin romper las reglas de esta, hay algunas tiendas curiosas que permiten controlar los recados más complejos. En el caso de que una tienda, por ejemplo, pueda conseguir el producto a partir de varios derivados, necesitamos decirle al dron que puede conseguir uno u otro. Similar a un OR lógico. También es posible que una tienda requiera de más de un producto para llevar a cabo la transacción, por lo que igual manera, necesitamos decirle al dron que necesitamos un producto y el siguiente. Similar a un AND.\nPara esto hay dos tiendas que se preocupan de entender estas complejidades.\nANDrés Store    Esta tienda se encarga de los encargos y requisitos que requieren de un AND lógico.\nCuando llega un dron buscado su producto (el AND) exminan los integrantes de AND. Por cada uno de los productos exmina si el dron ya los tiene o no. Y en el caso de no tenerlos le añade una instrucción para comprar ese produto.\nSiempre, antes de enviar el dron de vuelta a la torre elimina cualquier rastro de su actividad para mantener las cosas simples.\nHectOR    En este caso la tienda funciona de forma similar. Inspecciona la mochila del dron, Si ya tiene alguno de los elementos que necesita, borra el rastro de su tienda y lo envia a la torre.\nSi no tiene ninguno de los elementos HectOr fletará tantos drones clonados como elementos haya en la instrucción. De esta forma se asegura de que tendrán el máximo número de posibilidades para completar el recado con éxito. Esta operación es similar a la que lleva a cabo la torre cuando hay varias tiendas, pero en el caso de que haya varios requisitos.\n"},{"id":9,"href":"/Overlord/overview/actors/","title":"Actors","parent":"Overview","content":"En esta sección de documentación vamos a intentar dar una persepectiva desde puntos de vista más familiares a los usuarios que se pueden beneficiar de Overlord.\nAl ser una herramienta que abarca un escenario universal nos hemos dado cuenta que los usuarios tienden a verla desde su punto de vista, y les cuestra un poco dar el paso universal. Debido a esto usaremos un escenario familiar y luego expandiremos esa persepectiva para intentar describir Overlord.\n"},{"id":10,"href":"/Overlord/overview/rules/","title":"Rules","parent":"Overview","content":"En el caso de la ejecución de una regla completa podemos ver el proceso de abstracción completo desde la regla más general, llegando a un trozo de código ejecutado.\nEste es un ejemplo sencillo y puntual, se reserva para otras ejemplos una regla fallida, una regla incompleta y otros escenario secundarios. Actualmente la PoC de Overlord está centrada en la viabilidad por lo que se ciñe a los \u0026ldquo;Happy Path\u0026rdquo;.\nTambién queda excluido del ejemplo el log, que debido a su extensión, resultaría muy complejo de explicar detalladamente. En el log estarán los resultados parciales de todas las ejecuciones, herramientas y caminos del grafo dinámico descartados.\nUna regla completa     .gdoc-expand { margin-bottom: 0rem; margin-top: 0rem; } .blue{ background-color: #9acdff; }   Recomendación / Regla General ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) En este punto una regla es una recomendación abstracta de alto nivel. Su principal función es permitir una idea transversal a todos los proyectos de la empresa, con esta se puede saber de forma global si las todas las comunicaciones de la empresa cumplen con este control.\nTambién permite la colaboración entre empresas a un nivel muy general.\nEn esta regla podemos ver varios conceptos generales como la palabra reservada All que indica que esta regla debe ser cierta para todos los integrantes siguientes. También podemos ver unas palabras entre parentesis; estos son los parámetros que permiten instanciar esta regla para un entorno en concreto.\nNo te fijes en los detalles funcionales de la regla, según esta progrese por el sistema entenderás todo el proceso.\nActores    Los principales productores de este tipo de reglas serán:\n Los grupos de trabajo dedicados a seguridad (Ej: OWASP) Las agencias de seguridad y estandarización (Ej: NIST) Los líderes de la industría a nivel de seguridad  Los principales interesados en estas reglas serán:\n Los CISO y CTO de todas las empresas    \u0026#43;Hash ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 Esta regla tiene un Hash SHA256 para poder hacer referencia a ella en las discusiones de la comunidad.\n  Instanciación General ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 En este punto de la regla estamos especificando que en nuestra empresa consideramos segura una versión de TLS de 1.3 o superior. Este bloque permite establecer los parámetros, que como vimos en el punto anterior tienen un símbolo \u0026ldquo;$\u0026rdquo; y además están entre paréntesis.\nSi te fijas este parámetro tiene las letras ch antes del símbolo del \u0026ldquo;$\u0026rdquo;, esto le dice a Overlord que ese parámetro solo se puede especificar en la fase de \u0026ldquo;Check\u0026rdquo;; que es donde se establecen los criterios transversales a la organización.\nEste tipo de decisiones suelen ser las que están expresadas como controles de seguridad. Estos controles idealmente son el resultado de un proceso de treat modeling.\nActores    Este tipo de decisiones se toman a nivel transversal en una organización. Incluuyen no solo al CISO o CTO sino también a los técnicos de seguridad de más alto nivel y experiencia.\n  \u0026#43;Hash ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 Esta regla tiene un Hash SHA256 para poder hacer referencia a ella en los sistemas de segimiento de riesgos transversales a la compañía.\n  Apuntado ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 Dentro del proceso de testing de riesgos es necesario agregar algunos parámetros técnicos del proyecto concreto. En este caso estamos agregando un parámetro que no esta explícitamente en la regla, de forma que el Overlord priorice los caminos que usan esta información.\nEsto es así porque dentro del proceso de comprobación de controles de seguridad el como se hacen las cosas puede ser relevante en un determinado momento. Debido a esto el grafo dinámico usará preferentemente los caminos, para obtener los datos, usando los datos que ya posee primero.\nActores    En este caso tanto el responsable ténico como su equipo están involucrados en el proceso. Es necesario inspeccionar los resultados parciales de Overlord para distinguir de aquellas posibilidades de obtención de información aquellas que son utilizables en el proyecto actual.\nEs de este proceso de revisión de donde se puede consultar que parámetros extra se pueden proveer para que Overlord compruebe de una u otra forma.\nEn este proceso de selección es posible que los responables de auditoría y seguridad puedan aportar su perspectiva de que nivel de comprobación es adecuado.\nTambién pueden ver en el log como se ha llevado a cabo la comprobación sin necesidad de convenirla previamente; de forma que se conserve el principio de federación de Overlord.\n  \u0026#43;Hash ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 En este caso el identificador del proceso de targeting incluye el parámetro técnico. Este cambiará en el caso de que el servidor dns asociado a este proceso particular cambie. Overlord refuerza la transparencia siempre que es posible.\nEn el caso de que no sea relevante simplemente podemos hacer referencia al identificador del nivel superior y de esa forma no tendremos notificaciones cada vez que cambie un detalle del entorno.\n  Ejecución ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] Para la ejecución podemos proveer a la regla del resto de parámetros necesarios. En este caso los nombres de dominio implicados en el test del control.\nActores    En este caso los encargados de la ejecución del código de comprobación, ya sea de forma manual o automatizada. Pueden incluir los siguientes perfiles:\n Desarrolladores interesados en mejorar la seguridad del código Auditores que quieran comprobar el estado de un control Expertos en seguridad que quieran comprobar el estados de un control    \u0026#43;Hash ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] == execution id 26b67743880b9bc6cbdbe66d51abd2d8846822bf7325d2e2bef08c611a6023d5 De nuevo el identificador contiene los parámetros de la ejecución de forma que no se puedan cambiar las condiciones de ejecución sin que este cambie\n  Resultado ↕  =\u0026gt; Rationale The communications with user must be secure =\u0026gt; Rule All ($url) must have (g$tls_version) \u0026gt;= (ch$version) == rule id 03669a7dfefe38399e193ca8455b7bc92a62b83fdf1991922234acbcde9f04c5 =\u0026gt; Check Block version = 1.3 == check id b125b13bfb29e13c2e4b9ed4d491c1656ccf693c9959b1517908399e82ba8779 =\u0026gt; Target Block dns_ip = 1.2.3.4 == target id 20038dd2edf3e8b8673d0e6c5e13b142bf81a88cde9a1c404f4ba3fb75ade4c1 \u0026lt;= cli params url = [one.com, two.com] == execution id 26b67743880b9bc6cbdbe66d51abd2d8846822bf7325d2e2bef08c611a6023d5 == Execution path dns_mask_tool ssl_tools rule_check == Final Rule All [ (\u0026quot;one.com\u0026quot; as $url) must have (\u0026quot;1.3\u0026quot; as g$tls_version) \u0026gt;= (\u0026quot;1.3\u0026quot; as ch$version), (\u0026quot;two.com\u0026quot; as $url) must have (\u0026quot;1.3\u0026quot; as g$tls_version) \u0026gt;= (\u0026quot;1.3\u0026quot; as ch$version), ] == Result All Rules OK == Result id c04a56d97f7e8e6d506e15c9d37ef45849fdb90a06d6b21d8d41b6516adfc67b En el paso final, usando el grafo dinámico, seguimos los siguientes pasos:\n En primer lugar estamos ejecutando código que haciendo uso de la herramienta \u0026ldquo;DNSMask\u0026rdquo; resolverá las url usando un determinado servidor DNS (pasado como parámetro en el bloque \u0026ldquo;Target Block\u0026rdquo;). Luego se usa la herramienta de análisis de ssl y se extrae la propiedad buscada (tls_version). Se expande la regla con esta información. Se evalua  De esta forma obtenemos un \u0026ldquo;All Rules OK\u0026rdquo;. Nuestro control esta funcionando.\nAdicionalmente podemos ver que se ha generado un nuevo hash, que incluye datos de todo lo anterior.\nActores    El resultado de la ejecución es algo interesa a todos los implicados en el proceso. En este caso el hash además incluye la hora del sistema para que evitar que se reutilizen resultados anteriores. O para usar los resultados cacheados si la caducidad de la regla esta establecida (no en este ejemplo).\nLos bloques de código ejecutados son creados por los desarrolladores, si es que no existen ya. Es una responsabilidad compartida el elegir que trozos de código se cargan en Overlord.\n  "},{"id":11,"href":"/Overlord/intro/","title":"Intro","parent":"Overlord","content":"Overlord    Overlord es una implementación de ejemplo de la iniciativa SUSTO.\nOverlord plantea una solución válida al testing de seguridad universal y sistemático dentro de las empresas modernas.\n"},{"id":12,"href":"/Overlord/tags/","title":"Tags","parent":"Overlord","content":""}]